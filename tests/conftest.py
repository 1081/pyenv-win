import sys

import pytest
from tempenv import TemporaryEnvironment

import os
import subprocess
from pathlib import Path
from test_pyenv_helpers import touch, pyenv_setup


@pytest.fixture()
def src_path():
    return Path(__file__).parent.parent


@pytest.fixture()
def local_path(tmp_path):
    return tmp_path / 'local dir with spaces'


@pytest.fixture()
def pyenv_path(tmp_path):
    return tmp_path / 'pyenv dir with spaces'


@pytest.fixture()
def bin_path(pyenv_path):
    return pyenv_path / 'bin'


@pytest.fixture()
def shims_path(pyenv_path):
    return pyenv_path / 'shims'

@pytest.fixture()
def pyenv_bat(bin_path):
    return str(bin_path / 'pyenv.bat')

@pytest.fixture(scope='session', autouse=True, params=['AMD64', 'X86'],
                ids=['PYENV_FORCE_ARCH=AMD64', 'PYENV_FORCE_ARCH=X86'])
def arch(request):
    arch = request.param
    if request.session.testsfailed:
        pytest.skip(f'Skipping PYENV_FORCE_ARCH={arch} since at lease one test failed for PYENV_FORCE_ARCH=AMD64')
    with(TemporaryEnvironment({'PYENV_FORCE_ARCH': arch})):
        yield arch


@pytest.fixture()
def settings(arch):
    # This needs to return a callable so that `__new__` of Native and its siblings gets called after `PYENV_FORCE_ARCH`
    # has been set by the `arch` fixture instead of `__new__` being called during pytest's collection phase.
    return lambda: {}


@pytest.fixture(autouse=True)
def tmp_pyenv(tmp_path, pyenv_path, local_path, bin_path, shims_path, settings, arch):
    settings = settings()
    touch(tmp_path / '.python-version')
    settings['pyenv_path'] = pyenv_path
    settings['local_path'] = local_path
    os.mkdir(pyenv_path)
    os.mkdir(local_path)
    sys.path.insert(0, str(bin_path))
    sys.path.insert(1, str(shims_path))
    pyenv_setup(settings)
    prev_cwd = os.getcwd()
    os.chdir(local_path)
    yield
    os.chdir(prev_cwd)
    sys.path.remove(str(bin_path))
    sys.path.remove(str(shims_path))


@pytest.fixture()
def exec(tmp_pyenv):
    def execute(*args):
        args = ['cmd', '/d', '/c', 'call'] + list(args)
        result = subprocess.run(args, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stderr = str(result.stderr, "utf-8").strip()
        # \x0c: generated by cls in cmd AutoRun
        stdout = str(result.stdout, "utf-8").rpartition('\x0c')[2].strip("\r\n")
        return stdout, stderr

    return execute


@pytest.fixture()
def pyenv(tmp_pyenv, pyenv_bat, exec):
    class PyEnv:
        def __getattr__(self, item):
            def command(*args):
                return exec(pyenv_bat, item, *args)

            return command

        def __call__(self, *args, **kwargs):
            return exec(pyenv_bat, *args)

    return PyEnv()
